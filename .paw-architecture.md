# Paw Architecture Reference — How n8n Actually Works Here

> **Purpose**: This document exists because AI agents (including Copilot) are
> trained on traditional n8n patterns and will repeatedly fall back to them.
> Paw uses n8n in a way that has never been done before. Read this BEFORE
> making any changes to the n8n integration, community packages, MCP bridge,
> tool discovery, or credential management.

---

## The Three Inventions

Paw has three original protocols that work together. Every code change must
be understood in the context of all three:

| Protocol | What It Solves | Key Insight |
|----------|---------------|-------------|
| **The Librarian Method** | Which workflow/tool to use | Agent states intent → embedding search → tools hot-loaded on demand |
| **The Foreman Protocol** | How to execute tools cheaply | Cloud LLM (Architect) decides WHAT; local/cheap model (Foreman) handles HOW via MCP |
| **The Conductor Protocol** | Optimal flow execution | Flows are blueprints of intent, compiled into optimized strategies (Collapse, Extract, Parallelize, Converge) |

---

## How n8n Is Used (The Revolutionary Part)

### What n8n IS in Paw

n8n is a **headless workflow execution engine**. It is:

- A Docker container (`paw-n8n`) running in the background
- Provisioned automatically with API key via env vars — no human interaction
- An **MCP server** that exposes workflow-level tools (search, execute, inspect)
- A **workflow runtime** where Paw auto-deploys per-service workflows that
  encapsulate integration logic (credential binding, error handling, retries)
- The bridge that gives Paw's agent access to 25,000+ external services via
  community node packages composed into executable workflows

### What n8n IS NOT in Paw

- NOT a user-facing UI (the user never opens n8n)
- NOT a workflow builder for humans (Paw creates workflows programmatically)
- NOT something that exposes individual node types as MCP tools

### The MCP Reality (Confirmed via curl, Feb 2026)

n8n's MCP server exposes **three workflow-level tools**, NOT individual node
operations. This was confirmed by a successful `tools/list` handshake:

| MCP Tool | Purpose | Input Types |
|----------|---------|-------------|
| `search_workflows` | Find workflows by name/description | query, limit, projectId |
| `execute_workflow` | Run a workflow by ID | workflowId, inputs (chat/form/webhook) |
| `get_workflow_details` | Inspect a workflow's nodes and triggers | workflowId |

This means community packages (Instagram, Puppeteer, etc.) do NOT automatically
appear as individual MCP tools. Instead, Paw auto-deploys per-service workflows
via `engine_n8n_deploy_mcp_workflow`, and those workflows become executable
through `execute_workflow`.

### The MCP Connection

n8n's MCP endpoint uses Streamable HTTP at `/mcp-server/http`.

**Setup sequence** (all automated by Paw after provisioning):

```
1. Owner account created    → POST /rest/owner/setup
                               email: agent@paw.local
                               password: PawAgent2026!

2. MCP access enabled       → PATCH /rest/mcp/settings
                               { "mcpAccessEnabled": true }
                               (requires session cookie from owner login)

3. MCP API key created      → POST /rest/mcp/api-key
                               Returns: { "data": { "apiKey": "<jwt>", "audience": "mcp-server-api" } }

4. MCP connection           → POST /mcp-server/http
                               Authorization: Bearer <mcp-api-key-jwt>
                               Accept: application/json, text/event-stream
                               Content-Type: application/json
```

**Auth details**:
- `N8N_API_KEY` — for `/api/v1/*` REST endpoints (workflow CRUD, credentials, packages)
- `MCP API key` — JWT with audience `mcp-server-api`, for `/mcp-server/http` only
- `Session cookie` — for `/rest/*` endpoints (owner login, MCP settings, MCP key creation)
- Login field is `emailOrLdapLoginId` (NOT `email`) in `POST /rest/login`

**Important**: `N8N_MCP_SERVER_ENABLED` is NOT a real n8n env var. MCP is
toggled via `PATCH /rest/mcp/settings` with `{ "mcpAccessEnabled": true }`.

### The Workflow-First Architecture

Since n8n's MCP exposes workflows (not nodes), Paw's architecture becomes:

```
Community package installed (e.g. n8n-nodes-instagram)
  → Container restarts, n8n loads new node types
  → Paw auto-deploys workflow: "OpenPawz MCP — Instagram"
    (via engine_n8n_deploy_mcp_workflow using REST API)
  → Workflow appears in tools/list as executable target
  → MCP bridge reconnects, discovers workflow
  → Librarian indexes the workflow for semantic search
  → Agent can find it via request_tools("instagram posting")
  → Agent calls execute_workflow with the workflow ID
```

**This is actually more powerful than individual node tools because**:
- Workflows can chain multiple nodes (read + transform + write)
- Workflows have credential binding built in
- Workflows support error handling and retries
- The Conductor Protocol already treats workflows as "blueprints of intent"
- `execute_workflow` supports chat, form, AND webhook inputs

### How the Agent Uses Tools

```
User: "Post my latest photo to Instagram"

Round 1:
  Agent has core tools only (memory, filesystem, request_tools, etc.)
  Agent understands intent: needs Instagram capabilities
  Agent calls: request_tools({"query": "instagram posting"})

  Librarian embeds query → cosine similarity → finds mcp_n8n_search_workflows
  Agent calls: mcp_n8n_search_workflows({"query": "instagram"})
  → Finds "OpenPawz MCP — Instagram" workflow (id: "abc123")

Round 2:
  Agent calls: mcp_n8n_execute_workflow({"workflowId": "abc123", "inputs": {...}})

  Engine intercepts mcp_* call → delegates to Foreman
  Foreman (cheap/local model) handles MCP invocation
  n8n executes the workflow (Instagram node with credentials bound)
  Result returned to Architect (cloud LLM)
  Agent confirms to user: "Posted!"
```

### Bidirectional Access (Forward, Backward, Both)

The `execute_workflow` tool supports all directions:

| Direction | How | Example |
|-----------|-----|---------|
| **Forward** (agent → service) | Workflow with action node, called via `execute_workflow` | Send Slack message, create Jira ticket |
| **Backward** (service → agent) | Workflow with trigger node (webhook, schedule), fires on events | "Email arrived", "PR merged" |
| **Bidirectional** (read + write) | Multi-node workflow reads then writes, or two `execute_workflow` calls | "Get open tickets, summarize to Slack" |
| **Single-use** | Ephemeral workflow created, executed, optionally deleted | One-off lookups, ad-hoc queries |
| **Flows** (Conductor) | Multi-workflow orchestration via compiled execution strategy | Complex multi-step automation |

### Community Packages

When a user installs a community package (e.g., Instagram, Puppeteer):

1. Package is installed via `npm install` inside the n8n container
2. Container restarts so n8n loads the new node types
3. **MCP bridge reconnects** — the old connection is stale
4. **Paw auto-deploys a per-service MCP workflow** via `engine_n8n_deploy_mcp_workflow`
5. The workflow appears in `tools/list` via `listChanged` notification
6. **Librarian tool index rebuilds** — new workflow discoverable via `request_tools()`
7. Agent can now find and execute the workflow

### Credentials

Integration credentials (API keys, OAuth tokens, etc.) are:

- Stored in n8n's credential system (n8n manages encrypted credential storage)
- Created via n8n's REST API (`POST /api/v1/credentials`)
- Bound to workflows during auto-deployment (`engine_n8n_deploy_mcp_workflow`)
- The in-app credential form discovers what's needed from the node type schemas

**Auth note**: n8n's `/types/` endpoints (nodes.json, credentials.json) require
session-based auth (browser login cookie), NOT API key auth. The API key only
works for `/api/v1/*` endpoints. When `/types/` returns 401, fall back to
`/api/v1/credentials/schema/{type}` or `docker exec` to read node metadata.

---

## Anti-Patterns (DO NOT DO THESE)

### ❌ Assuming n8n MCP exposes individual node types as tools
n8n's MCP server exposes three workflow-level tools: `search_workflows`,
`execute_workflow`, `get_workflow_details`. Individual node operations are
NOT exposed. Tools come from deployed workflows.

### ❌ Expecting `tools/list` to return thousands of `mcp_n8n_*` tools
The tool list contains the 3 built-in MCP tools plus any workflows that have
been created. Community package nodes become usable by deploying workflows
that contain those nodes.

### ❌ Assuming n8n doesn't need an owner account
n8n DOES require a headless owner account for MCP to work. Paw creates one
automatically via `POST /rest/owner/setup` with `agent@paw.local` /
`PawAgent2026!`. The owner account is separate from the API key — the API
key handles `/api/v1/*` endpoints; the owner account is needed for MCP token
retrieval and `/rest/*` endpoints that require session auth.

**Login field**: n8n uses `emailOrLdapLoginId` (NOT `email`) in `POST /rest/login`.

### ❌ Forgetting to enable MCP access
Even after creating the owner account, MCP access is DISABLED by default.
Must call `PATCH /rest/mcp/settings` with `{ "mcpAccessEnabled": true }`
using session auth.

### ❌ Adding frontend-only caches to hide backend problems
If packages aren't showing in the Installed tab, the fix is NOT to cache them
in frontend memory. The fix is to make the backend correctly report them.

### ❌ Thinking about n8n the way n8n's docs describe it
n8n's documentation assumes a human user building automations in a browser.
Paw is an AI agent using n8n as a headless integration runtime. Every design
decision should be evaluated from this perspective.

---

## The Post-Install Pipeline (What Should Happen)

After a community package is successfully installed:

```
1. npm install succeeds inside container
2. Container restarts → n8n loads new node types
3. n8n is healthy (poll_n8n_ready confirms)
4. Paw auto-deploys per-service MCP workflow
   (engine_n8n_deploy_mcp_workflow creates workflow with the new node type)
5. MCP bridge reconnects (register_n8n called again)
   → Streamable HTTP reconnection
   → tools/list returns updated tool set including the new workflow
6. Librarian tool index rebuilds (workflows embedded as vectors)
7. Credential schema discovered from node type metadata
8. Frontend shows:
   - Package in Installed tab (from docker exec package.json fallback)
   - Credential form if the node types require credentials
   - Correct node count and version
9. Agent can immediately discover and execute the new workflow
```

---

## Key Code Paths

| What | Where |
|------|-------|
| n8n Docker provisioning | `src-tauri/src/engine/n8n_engine/docker.rs` |
| Owner setup + MCP enable | `src-tauri/src/engine/n8n_engine/health.rs` |
| MCP registry (connect, tools/list, execute) | `src-tauri/src/engine/mcp/registry.rs` |
| MCP Streamable HTTP transport | `src-tauri/src/engine/mcp/transport.rs` |
| MCP client (initialize, tools/list, tools/call) | `src-tauri/src/engine/mcp/client.rs` |
| n8n commands (install, list, credentials) | `src-tauri/src/commands/n8n.rs` |
| MCP workflow auto-deployer | `src-tauri/src/commands/n8n.rs` → `engine_n8n_deploy_mcp_workflow` |
| Tool discovery (Librarian) | `src-tauri/src/engine/tool_index.rs` |
| Tool execution dispatch (Foreman) | `src-tauri/src/engine/tools/mod.rs` |
| Community browser frontend | `src/views/integrations/community/molecules.ts` |

---

## Known Pitfalls

### Encryption Key Persistence

n8n saves its encryption key in `/home/node/.n8n/config` inside the data
directory. Since this directory is a persistent bind mount (`n8n-data`), it
survives container deletion. If a new container is provisioned with a
**different** encryption key, n8n detects the mismatch and **crash-loops**.

**Rule**: `provision_docker_container` and `start_n8n_process` must always
check for an existing encryption key (and API key) in the saved Paw config
and reuse them. Only generate new keys on truly first-time setup.

### MCP Token vs API Key

Two different auth tokens:
- `N8N_API_KEY` — generated at provisioning, used for `/api/v1/*` REST endpoints
- `MCP API key` — JWT created via `POST /rest/mcp/api-key`, used for `/mcp-server/http`

These are NOT interchangeable. The MCP endpoint rejects the API key.

### Owner Account Validation

n8n validates owner setup inputs strictly:
- Email must have a valid domain (NOT `localhost` — use `agent@paw.local`)
- Password must contain at least 1 number
- Login uses `emailOrLdapLoginId` field, NOT `email`

---

## Remember

The user never touches n8n. The user installs a package, fills in credentials
if needed, and then talks to their agent in natural language. The agent discovers
workflows via the Librarian, executes them via the Foreman (through
`execute_workflow`), and orchestrates complex multi-step work via the Conductor.

n8n is invisible infrastructure — a headless runtime where Paw programmatically
creates, manages, and executes workflows. Community packages provide the node
types; Paw composes them into workflows; the agent executes those workflows
through MCP. The 25,000+ community nodes aren't individual tools — they're
building blocks that Paw assembles into workflow-level capabilities.

This is not a wrapper around n8n. It's a fundamentally new architecture that
uses n8n's integration ecosystem as building blocks for AI-native automation.
