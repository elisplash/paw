# Paw Architecture Reference — How n8n Actually Works Here

> **Purpose**: This document exists because AI agents (including Copilot) are
> trained on traditional n8n patterns and will repeatedly fall back to them.
> Paw uses n8n in a way that has never been done before. Read this BEFORE
> making any changes to the n8n integration, community packages, MCP bridge,
> tool discovery, or credential management.

---

## The Three Inventions

Paw has three original protocols that work together. Every code change must
be understood in the context of all three:

| Protocol | What It Solves | Key Insight |
|----------|---------------|-------------|
| **The Librarian Method** | Which tool to use among 25,000+ | Agent states intent → embedding search → tools hot-loaded on demand |
| **The Foreman Protocol** | How to execute tools cheaply | Cloud LLM (Architect) decides WHAT; local/cheap model (Foreman) handles HOW via MCP |
| **The Conductor Protocol** | Optimal flow execution | Flows are blueprints of intent, compiled into optimized strategies (Collapse, Extract, Parallelize, Converge) |

---

## How n8n Is Used (The Revolutionary Part)

### What n8n IS in Paw

n8n is a **headless service runtime**. It is:

- A Docker container (`paw-n8n`) running in the background
- Provisioned automatically with API key via env vars — no human interaction
- An **MCP server** that exposes integration node types as callable tools
  (requires `N8N_MCP_SERVER_ENABLED=true` env var on the container)
- The bridge that gives Paw's agent access to 25,000+ external services

### What n8n IS NOT in Paw

- NOT a user-facing UI (the user never opens n8n)
- NOT a workflow builder (the user does not create n8n workflows)
- NOT something that needs a setup wizard or login
- NOT something that needs manually-created workflows to expose tools

### The MCP Connection

n8n exposes an instance-level MCP server. The endpoint and transport depend
on the n8n version:

| n8n Version | Endpoint | Transport |
|------------|----------|-----------|
| v2.2.0+ | `/mcp-server/http` | Streamable HTTP |
| Older | `/mcp/sse` | SSE (legacy) |

**Important**: `N8N_MCP_SERVER_ENABLED` is NOT a real n8n env var. MCP is
toggled via the n8n settings UI or API. Paw enables it by creating a headless
owner account via `POST /rest/owner/setup` after provisioning.

Auth uses `Authorization: Bearer <token>`. Paw tries the API key as Bearer
token. The `register_n8n()` function tries Streamable HTTP first, then falls
back to SSE for older versions.

The flow:
```
n8n starts → owner account created automatically → MCP available
Paw connects → Streamable HTTP POST → initialize handshake → tools/list
tools/list returns available tools as MCP tool definitions
Tools indexed by Librarian (embedded as vectors for semantic search)
Agent can now discover and use any n8n integration via natural language
```

### Community Packages

When a user installs a community package (e.g., Instagram, Puppeteer):

1. Package is installed via `npm install` inside the n8n container
2. Container restarts so n8n loads the new node types
3. **MCP bridge must reconnect** — the old SSE connection is stale
4. `tools/list` now returns the new tools from the installed package
5. **Librarian tool index must rebuild** — new tools need to be embedded
6. Agent can now discover the new tools via `request_tools()`

### How the Agent Uses Tools

```
User: "Post my latest photo to Instagram"

Round 1:
  Agent has core tools only (memory, filesystem, request_tools, etc.)
  Agent understands intent: needs Instagram capabilities
  Agent calls: request_tools({"query": "instagram posting"})

  Librarian embeds query → cosine similarity → finds mcp_n8n_instagram_*
  Tools hot-loaded into this round

Round 2:
  Agent now has Instagram tools available
  Agent calls: mcp_n8n_instagram_post({...})

  Engine intercepts mcp_* call → delegates to Foreman
  Foreman (cheap/local model) handles MCP invocation
  Result returned to Architect (cloud LLM)
  Agent confirms to user: "Posted!"
```

### Credentials

Instagram, Slack, etc. need API keys/tokens to work. These credentials are:

- Stored in n8n's credential system (n8n manages encrypted credential storage)
- Created via n8n's REST API (`POST /api/v1/credentials`)
- Associated with the credential type that the node expects
- The in-app credential form discovers what's needed from the node type schemas

When credential schema discovery works properly:
1. After package install, query n8n's `/types/nodes.json` for the package's node types
2. Each node type declares which credential types it needs
3. Query `/types/credentials.json` for the field schemas of those credential types
4. Render the form in-app so the user never opens n8n

**Auth note**: n8n's `/types/` endpoints (nodes.json, credentials.json) require
session-based auth (browser login cookie), NOT API key auth. The API key only
works for `/api/v1/*` endpoints. When `/types/` returns 401, fall back to
`/api/v1/credentials/schema/{type}` for individual credential schemas, or use
`docker exec` to read node metadata from the container filesystem.

---

## Anti-Patterns (DO NOT DO THESE)

### ❌ Creating n8n workflows to expose tools
n8n's MCP endpoint exposes node operations directly. You do NOT need to create
a workflow with an "MCP Server Trigger" node for tools to be available. That's
the traditional n8n way. Paw connects directly to the MCP endpoint.

### ❌ Calling `engine_n8n_deploy_mcp_workflow` for community packages
This command was designed for the Services tab where specific service workflows
are needed. Community packages expose tools through MCP directly — no workflow
deployment needed.

### ❌ Assuming n8n needs a setup wizard / login / owner setup
n8n is provisioned with `N8N_API_KEY` and `N8N_BASIC_AUTH_ACTIVE=false`. The
API key IS the auth. If the REST API returns 404, it's a version/endpoint
issue, not a setup issue.

### ❌ Adding frontend-only caches to hide backend problems
If packages aren't showing in the Installed tab, the fix is NOT to cache them
in frontend memory. The fix is to make the backend correctly report them. Local
caches (`_localInstalled`) mask real issues and create inconsistency.

### ❌ Thinking about n8n the way n8n's docs describe it
n8n's documentation assumes a human user building automations in a browser.
Paw is an AI agent using n8n as a headless integration runtime. Every design
decision should be evaluated from this perspective.

---

## The Post-Install Pipeline (What Should Happen)

After a community package is successfully installed:

```
1. npm install succeeds inside container
2. Container restarts → n8n loads new node types
3. n8n is healthy (poll_n8n_ready confirms)
4. MCP bridge reconnects (register_n8n called again)
   → Streamable HTTP reconnection (or SSE fallback)
   → tools/list returns updated tool set including new package's tools
5. Librarian tool index rebuilds (new tools embedded as vectors)
6. Credential schema discovered from node type metadata
7. Frontend shows:
   - Package in Installed tab (from docker exec package.json fallback)
   - Credential form if the node types require credentials
   - Correct node count and version
8. Agent can immediately discover and use the new tools
```

### What's Currently Broken

- Step 4: MCP endpoint may require owner account + explicit enablement.
  register_n8n now tries Streamable HTTP first, then SSE, and handles
  failure gracefully — the install pipeline works without MCP.
- Step 6: /types/credentials.json requires session auth (401 with API key).
  Per-credential fallback at /api/v1/credentials/schema/{type} may work.
- Step 7: Community packages REST API returns 404 (docker exec fallback works).

### The Fix Strategy

The fix must flow from the architecture, not from symptoms:

1. **MCP reconnection after install** — After container restart and health check,
   call `register_n8n()` again. Now tries Streamable HTTP at `/mcp-server/http`
   first (with Bearer token auth), falls back to SSE at `/mcp/sse`.

2. **Package detection** — REST API for community-packages returns 404 on newer
   n8n. Docker exec fallback reads `/home/node/.n8n/package.json` — the name
   filter must handle scoped packages like `@apify/n8n-nodes-apify`.

3. **Tool index rebuild** — After MCP reconnection, rebuild the Librarian's
   `ToolIndex` so the new `mcp_n8n_*` tools are embedded and discoverable.

4. **Remove compensating hacks** — The `_localInstalled` cache, the broken
   `engine_n8n_deploy_mcp_workflow` call (with no args), and any other
   workarounds that exist to mask the real problems.

---

## Key Code Paths

| What | Where |
|------|-------|
| n8n Docker provisioning | `src-tauri/src/engine/n8n_engine/docker.rs` |
| MCP registry (connect, tools/list, execute) | `src-tauri/src/engine/mcp/registry.rs` |
| MCP SSE transport | `src-tauri/src/engine/mcp/transport.rs` |
| MCP client (initialize, tools/list, tools/call) | `src-tauri/src/engine/mcp/client.rs` |
| n8n commands (install, list, credentials) | `src-tauri/src/commands/n8n.rs` |
| Tool discovery (Librarian) | `src-tauri/src/engine/tool_index.rs` |
| Tool execution dispatch (Foreman) | `src-tauri/src/engine/tools/mod.rs` |
| Community browser frontend | `src/views/integrations/community/molecules.ts` |
| Health polling | `src-tauri/src/engine/n8n_engine/health.rs` |

---

## Known Pitfalls

### Encryption Key Persistence

n8n saves its encryption key in `/home/node/.n8n/config` inside the data
directory. Since this directory is a persistent bind mount (`n8n-data`), it
survives container deletion. If a new container is provisioned with a
**different** encryption key, n8n detects the mismatch and **crash-loops**.

**Rule**: `provision_docker_container` and `start_n8n_process` must always
check for an existing encryption key (and API key) in the saved Paw config
and reuse them. Only generate new keys on truly first-time setup.

---

## Remember

The user never touches n8n. The user installs a package, fills in credentials
if needed, and then talks to their agent in natural language. The agent discovers
tools via the Librarian, executes them via the Foreman, and orchestrates complex
multi-step work via the Conductor. n8n is invisible infrastructure — a headless
runtime that happens to give the agent access to 25,000+ services.

This is not a wrapper around n8n. It's a fundamentally new architecture that
uses n8n's integration ecosystem as building blocks for AI-native automation.
